Орлов Михаил Федорович Р3123 504537

Отчет по лабораторной работе:

1. Программа собрана логично и по модулям. Главная функция `gen_bin_tree` отдельно считает ветки дерева через `left_branch` и `right_branch`. Для сравнения, как лучше хранить дерево, попробовал разные структуры данных: `gen_bin_tree_list` и `gen_bin_tree_tuple`.

2. Функиция `gen_bin_tree()` умеет гибко работать с данными и проверять их:
    1) Не даст ввести отрицательную высоту дерева (выдаст `ValueError`).
    2) Если свои функции для веток не указаны, возьмет стандартные `l_b` и `r_b`.
    3) Можно задавать любые формулы для веток через `lambda`-функции или обычные функции.
    4) Числа, которые получаются для ключей словаря, преобразует в текст.

3. В программе есть разные варианты использования:
    1) Можно построить стандартное дерево по заданию (root=13, height=3).
    2) Можно задать свои функции для левой и правой ветки через параметры `l_b` и `r_b`.
    3) Деревья могут быть разной высоты (0, 1, 2 и больше).
    4) Можно менять значение корня дерева.

4. Тесты проверяют:
    1) Как строятся деревья высотой 0, 1 и 2.
    2) Как работает программа со стандартными настройками (высота 3, корень 13).
    3)  Функции разных типов (сложение, умножение, возведение в степень).
    4) `Lambda`-функции, чтобы гибко задавать формулы для веток.
    5) Разные значения для корня дерева.
    6) Правильно ли обрабатываются ошибки (отрицательная высота).
    7) Как работают альтернативные структуры данных (список, кортеж).

5. Код оформлен по правилам PEP-257:
    1) У каждой функции есть описание, что она делает, какие параметры принимает и что возвращает.
    2) Чтобы код было легче понимать, использованы аннотации типов (`Callable`, `Optional`).
    3) В комментариях объясняются важные моменты в алгоритмах.

6. В исследовательской части:
    1) Посмотрел, как лучше хранить дерево: в словаре, списке или кортеже.
    2) Показал, что удобно передавать функции для веток как параметры.
    3) Доказал, что программа работает и со старыми параметрами из задания.

7.  В программе использованы хорошие принципы разработки:
    1)  Можно добавлять новые функции для веток, не меняя основной код.
    2)  Каждая функция отвечает только за что-то одно.
    3)  Дерево строится с помощью рекурсии, что естественно для такой структуры.

8. Решение показывает, что программу можно использовать для построения разных бинарных деревьев с разными способами ветвления.
