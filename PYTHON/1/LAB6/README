Орлов Михаил Федорович Р3123 504537

Отчет по лабораторной работе:

1. Программа реализует построение бинарного дерева двумя способами:
  1) Рекурсивно — с использованием вложенных вызовов функции build_tree_recursive().
  2) Итеративно — через цикл и структуру collections.deque (build_tree_iterative()).

2. Особенности функций:
  1) Обе функции принимают параметры: высота дерева (height), корень (root) и функции вычисления потомков.
  2) Если параметры не переданы, используются значения по умолчанию.
  3) В рекурсивной версии дерево хранится как вложенные словари.
  4) В итеративной версии узлы записываются в словарь с путями вида root.left.right.

3. Свойства дерева:
  1) Корень (root = 13) задаётся пользователем.
  2) Высота (height) изменяется от 1 до 20 для анализа времени.
  3) Левый потомок вычисляется по формуле root + 1.
  4) Правый потомок вычисляется по формуле root - 1.

4. Измерение времени работы:
  1) Для замеров использован модуль timeit.
  2) Проведено сравнение четырёх вариантов:
    - Рекурсивный и итеративный без кэширования.
    - Рекурсивный и итеративный с кэшированием (@cache).
    - Рекурсивный: с и без кэша.
    - Итеративный: с и без кэша.
  3) Результаты визуализированы с помощью библиотеки matplotlib.

5. Документация и оформление:
  1) Все функции снабжены docstring по стандарту PEP 257.
  2) Использованы аннотации типов (int, Callable, dict[str, int]).
  3) Код структурирован, каждая функция выполняет одну задачу.
  4) Кэширование реализовано через декоратор functools.cache.

6. Результаты эксперимента:
  1) Время построения обоих типов деревьев растёт с увеличением высоты.
  2) Итеративная версия работает немного быстрее при больших высотах.
  3) Кэширование значительно сокращает время выполнения при повторных вызовах.
  4) Зависимость времени от высоты близка к линейной при малых высотах и экспоненциальной при больших.

7. Вывод:
  1) Рекурсивный и итеративный подходы дают одинаковую структуру дерева.
  2) Итеративная реализация более устойчива и быстрее при глубоком дереве.
  3) Кэширование повышает эффективность обоих методов.
